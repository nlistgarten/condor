import condor as co
from condor.backends.casadi.utils import (
    flatten, wrap, symbol_class, substitute, recurse_if_else
)
import casadi
import spiceypy as spice
import os
import numpy as np

#class ExternalSolverWrapperType(co.ModelType):
def copy_field(new_model_name, old_field, new_field=None):
    if new_field is None:
        new_field = old_field.inherit(
            new_model_name, field_type_name=old_field._name
        )
    new_field._symbols = [ sym for sym in old_field ]
    new_field._count = sum(new_field.list_of("size"))
    return new_field

class ExternalSolverWrapperType(type):
    """
    since this is only one case, only need to bind input and output fields
    explicitly -- and possibly this is just syntax sugar. wrapper doesn't need
    much from the metclass, primarily handled by ExternalSolverModel which is
    automatically generated by wrapper's __create_model__, injected automatically
    by model sub-types. Could just as easily create decorator or other
    class-method (on Wrapper) that consumes singleton/collection of functions

    IO fields just a nice way to create simple object with IO metadata. 
    """

    @classmethod
    def __prepare__(cls, model_name, bases, name="", **kwds):
        print("prepare for", model_name, bases, name)
        if name:
            model_name = name
        sup_dict = super().__prepare__(cls, model_name, bases, **kwds)
        if bases and ExternalSolverWrapper in bases: # should check MRO, I guess?
            print("copying IO fields to", model_name)
            for field_name in ["input", "output"]:
                sup_dict[field_name] = copy_field(
                    model_name, getattr(ExternalSolverWrapper, field_name)
                )
        return sup_dict

    def __new__(cls, model_name, bases, attrs, parameterized_IO=False, **kwargs):
        print("before calling __new__")
        if not bases:
            print("using type.new", model_name)
            new_cls = type.__new__(
                cls, model_name, bases, attrs, **kwargs
            )
        else:
            print("using super().new", model_name)
            new_cls =  super().__new__(
                #cls, model_name, bases, attrs, **kwargs
                cls, model_name, bases, attrs, parameterized_IO=parameterized_IO,**kwargs
            )
        return new_cls

    def __call__(cls, *args, **kwargs):
        # gets called on instantiation of the user wrapper, so COULD return the
        # condor model instead of the wrapper class -- perhaps this is more condoric,
        # not sure what's preferable
        # actully, this can get used instead of create model with init wrapper? no,
        # don't have access to instance yet.
        print(cls, "__call__")
        wrapper_object = super().__call__(*args, **kwargs)
        return wrapper_object.condor_model

class ExternalSolverModel(co.Model):
    input = co.FreeField()
    output = co.FreeField(co.Direction.output)


class CasadiFunctionCallbacki(casadi.Callback):
    """Base class for wrapping a Function with a Callback
    """

    def __init__(self, placeholder_func, wrapper_func, implementation, jacobian_of=None,  opts={}):
        casadi.Callback.__init__(self)
        self.wrapper_func = wrapper_func
        self.placeholder_func = placeholder_func
        self.jacobian = None
        self.jacobian_of = jacobian_of
        self.implementation = implementation
        self.opts = opts

    def init(self):
        pass

    def finalize(self):
        pass

    def get_n_in(self):
        return self.placeholder_func.n_in()

    def get_n_out(self):
        return self.placeholder_func.n_out()

    def eval(self, args):
        try:
            out = self.wrapper_func(
                *wrap(self.implementation.model.input, args[0])
            )
        except Exception as e:
            breakpoint()
            pass
        if self.jacobian_of:
            jac_out = np.concatenate(
                flatten(out)
            ).reshape(self.get_sparsity_out(0).shape)
            return jac_out,
        return casadi.vertcat(*flatten(out)),
        return [out] if self.get_n_out() == 1 else out
        #return out,
        return casadi.vertcat(*flatten(out)),
        return [out] if self.get_n_out() == 1 else out

    def get_sparsity_in(self, i):
        if self.jacobian_of is None or i < self.jacobian_of.get_n_in():
            return self.placeholder_func.sparsity_in(i)
        elif i < self.jacobian_of.get_n_in() + self.jacobian_of.get_n_out():
            # nominal outputs are 0
            return casadi.Sparsity(*self.jacobian_of.get_sparsity_out(
                i-self.jacobian_of.get_n_in()
            ).shape)
        else:
            raise ValueError

    def get_sparsity_out(self, i):
        return casadi.Sparsity.dense(*self.placeholder_func.sparsity_out(i).shape)

    def has_jacobian(self):
        return self.jacobian is not None

    def get_jacobian(self, name, inames, onames, opts):
        return self.jacobian


class CasadiExternalSolverImplementation:
    def __init__(self, model):
        self.model = model
        self.wrapper = model.__external_wrapper__
        self.input = casadi.vertcat(*flatten(model.input))
        self.output = casadi.vertcat(*flatten(model.output))
        self.placeholder_func = casadi.Function(
            f"{model.__name__}_placeholder",
            [self.input],
            [self.output],
            dict(allow_free=True,),
        )
        self.callback = CasadiFunctionCallbacki(
            self.placeholder_func, self.wrapper.function, self, jacobian_of=None
        )
        if hasattr(self.wrapper, "jacobian"):
            self.callback.jacobian = CasadiFunctionCallbacki(
                self.placeholder_func.jacobian(),
                self.wrapper.jacobian,
                implementation=self,
                jacobian_of=self.callback
            )

            self.callback.jacobian.construct(
                self.callback.jacobian.placeholder_func.name(),
                self.callback.jacobian.opts
            )
        self.callback.construct(
            self.callback.placeholder_func.name(),
            self.callback.opts
        )



    def __call__(self, model_instance, *args):
        use_args = casadi.vertcat(*flatten(args))
        out = self.callback(use_args)
        if isinstance(out, casadi.MX):
            out = casadi.vertsplit(out)
        model_instance.bind_field(
            self.model.output,
            out,
        )


co.backend.implementations.ExternalSolverModel = CasadiExternalSolverImplementation

class ExternalSolverWrapper(
    metaclass=ExternalSolverWrapperType,
):
    input = co.FreeField()
    output = co.FreeField(co.Direction.output)

    def __init_subclass__(cls, singleton=True, **kwargs):
        # at this point, fields  are already bound by ExternalSolverWrapperType.__new__
        # but modifications AFTER construction can be doen here
        print("init subclass of", cls)
        cls.__original_init__ = cls.__init__
        cls.__init__ = cls.__create_model__

    def __create_model__(self, *args, condor_model_name="",**kwargs):
        print("create model of", self, self.__class__)
        # copy field so that any field modification by __original_init__ is onto the
        # copy
        print("copying IO fields to", condor_model_name)
        if not condor_model_name:
            # could use repr somehow? but won't exist yet...
            condor_model_name = self.__class__.__name__
        for field_name in ["input", "output"]:
            setattr(self, field_name, copy_field(
                condor_model_name, getattr(self, field_name)
            ))


        self.__original_init__(*args, **kwargs)
        # update and/or copy meta? -- no, create a __condor_model__ class which is the
        # actual model and call, etc. get mapped to that??

        attrs = co.ModelType.__prepare__(condor_model_name, (ExternalSolverModel,))
        # this copying feels slightly redundant...
        for field_name in ["input", "output"]:
            copy_field(
                condor_model_name,
                getattr(self, field_name),
                new_field=attrs[field_name],
            )
        attrs["__external_wrapper__"] = self
        self.condor_model = co.ModelType(
            condor_model_name, (ExternalSolverModel,), attrs
        )



os.chdir("/Users/bmargoli/projects/condor-flight/checkcases/lunar/")
spice.furnsh("mrotat.tm")

def left_quaternion_product_matrix(q):
    return np.array([
        [-q[1], -q[2], -q[3]],
        [q[0], -q[3], q[2]],
        [q[3], q[0], -q[1]],
        [-q[2], q[1], q[0]],
    ]).squeeze()


#class SpiceReferenceFrame(type):
class SpiceReferenceFrame(ExternalSolverWrapper, parameterized_IO=False):
    #dt = input()
    #q = output(shape=4)
    #omega = output(shape=3)

    #def __new__(cls, model_name, bases, attrs,  **kwargs):
    #    new_cls = super().__new__(cls, model_name, bases, attrs, **kwargs)
    #    return new_cls


    #def __call__(cls, inertial_frame_name, name, start_time_string):
    def __init__(self, inertial_frame_name, name, start_time_string):
        """
        or...
        cls.dt = cls.input(name="dt")
        cls.q = cls.input(shape=4, name="q")
        cls.omega = cls.input(shape=3, name="omega")

        OR
        allow something along the lines of "auto_create" flag, or figure it out based on
        context? lol

        cls.input(name="dt")
        cls.input(shape=4, name="q")
        cls.input(shape=3, name="omega")
        """
        self.input(name="dt")
        self.output(name="q", shape=4)
        self.output(name="omega", shape=3)

        self.inertial_frame_name = inertial_frame_name
        self.name = name
        self.start_time_string = start_time_string
        self.et_start = spice.str2et(start_time_string)
        #self.create_model()

    def function(cls, dt):
        # need cls ref to access things like inertial_frame_name, etc
        et = cls.et_start + dt
        name = cls.name
        SS = spice.sxform(cls.inertial_frame_name, cls.name, et)
        RR, omega_other = spice.xf2rav(SS)
        ang_vel = RR @ omega_other
        #quaternion = spice.m2q(RR.T.copy())
        #quaternion = spice.m2q(RR.copy())
        quaternion = spice.m2q(RR)
        quaternion[1:] *= -1
        return quaternion, ang_vel


    # allow jac_vec_prod, hessian, etc
    # okay, I guess a finite_difference_mixin would be easy to add -- 
    def jacobian(cls, t):
        q, ang_vel = cls.function(t)
        qjac = left_quaternion_product_matrix(q) @ ang_vel/2
        return qjac, np.zeros(3)

spice_reference_frame = SpiceReferenceFrame(
    "J2000", "moon_pa", "2026-1-28 6:42:03.51 UTC"
)
at_0 = spice_reference_frame(0)
print(at_0.input, at_0.output)

class Solve(co.AlgebraicSystem):
    dt = implicit_output(initializer=-50_000)
    sys = spice_reference_frame(dt)
    residual.qq = casadi.norm_2(at_0.q - casadi.vertcat(*sys.q.squeeze().tolist()))
    breakpoint()
    #residual.qq = casadi.DM(at_0.q) - sys.q

print(
    SpiceReferenceFrame(
        "J2000", "moon_pa", "2026-1-28 6:42:03.51 UTC"
    )(0)
)



import ndsplines
class TableLookup(ExternalSolverWrapper, ):
    def __init__(self, xx, yy, degrees):
        input_data = []
        for k, v in xx.items():
            self.input(name=k)
            input_data.append(v)
        output_data = []
        for k, v in yy.items():
            self.output(name=k)
            output_data.append(v)
        output_data = np.stack(output_data, axis=-1)
        self.interpolant = ndsplines.make_interp_spline(
            input_data, output_data, degrees
        )
        self.jac_interps = [
            self.interpolant.derivative(idx) for idx in range(self.interpolant.xdim)
        ]

    def function(self, *xx):
        return self.interpolant(np.array(xx).reshape(-1))[0, :],

    def jacobian(self, *xx):
        array_vals = [
            interp(np.array(xx).reshape(-1))[0, :]
            for interp in self.jac_interps
        ]
        # TODO -- original implementation did not have transpose, but generic version
        # needs it
        return_val = np.stack(array_vals, axis=1).T
        return casadi.DM(return_val),


data_yy = dict(
    sigma = np.array(
        [
            [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
            [0.2, 0.1833, 0.1621, 0.1429, 0.1256, 0.1101, 0.0966],
            [0.4, 0.3600, 0.3186, 0.2801, 0.2454, 0.2147, 0.1879],
            [0.6, 0.5319, 0.4654, 0.4053, 0.3526, 0.3070, 0.2681],
            [0.8, 0.6896, 0.5900, 0.5063, 0.4368, 0.3791, 0.3309],
            [1.0, 0.7857, 0.6575, 0.5613, 0.4850, 0.4228, 0.3712],
        ]
    ),
    sigstr = np.array(
        [
            [0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0],
            [0.04, 0.7971, 0.9314, 0.9722, 0.9874, 0.9939, 0.9969],
            [0.16, 0.7040, 0.8681, 0.9373, 0.9688, 0.9839, 0.9914],
            [0.36, 0.7476, 0.8767, 0.9363, 0.9659, 0.9812, 0.9893],
            [0.64, 0.8709, 0.9338, 0.9625, 0.9778, 0.9865, 0.9917],
            [1.0, 0.9852, 0.9852, 0.9880, 0.9910, 0.9935, 0.9954],
        ]
    ),
)
data_xx = dict(
    xbbar = np.linspace(0, 1.0, data_yy["sigma"].shape[0]),
    xhbar = np.linspace(0, 0.3, data_yy["sigma"].shape[1]),
)
Table = TableLookup(data_xx, data_yy, 1)
tt = Table(0.5, 0.5)
print(tt.input, tt.output)

class MyOpt3(co.OptimizationProblem):
    xx = variable()
    yy = variable()
    interp = Table(xx, yy)
    objective = (interp.sigma - 0.2)**2 + (interp.sigstr - .7)**2

    class Casadi(co.Options):
        exact_hessian = False

opt3 = MyOpt3()




import sys
sys.exit()

"""
class ExternalSolverModel(
    co.Model,
):
    input = co.FreeField()
    output = co.FreeField(co.Direction.output)
"""

class ExternalSolverModel(
    co.Model,
    metaclass=ExternalSolverModelType,
):
    input = co.FreeField()
    output = co.FreeField(co.Direction.output)

    def __init_subclass__(cls, parameterized_IO=True, **kwargs):

        breakpoint()
        cls.__original_init__ = cls.__init__
        cls.__init__ = cls.__create_model__

    def __create_model__(self, *args, condor_model_name="", **kwargs):
        breakpoint()
        pass

    def __call__(self, *args, **kwargs):
        return self.function(*args, **kwargs)



#class SpiceReferenceFrame(type):
class SpiceReferenceFrame(ExternalSolverModel, parameterized_IO=False):
    #dt = input()
    #q = output(shape=4)
    #omega = output(shape=3)

    #def __new__(cls, model_name, bases, attrs,  **kwargs):
    #    new_cls = super().__new__(cls, model_name, bases, attrs, **kwargs)
    #    return new_cls


    #def __call__(cls, inertial_frame_name, name, start_time_string):
    def __init__(self, inertial_frame_name, name, start_time_string):
        """
        or...
        cls.dt = cls.input(name="dt")
        cls.q = cls.input(shape=4, name="q")
        cls.omega = cls.input(shape=3, name="omega")

        OR
        allow something along the lines of "auto_create" flag, or figure it out based on
        context? lol

        cls.input(name="dt")
        cls.input(shape=4, name="q")
        cls.input(shape=3, name="omega")
        """
        self.input(name="dt")
        self.output(name="q", shape=4)
        self.output(name="omega", shape=3)

        self.inertial_frame_name = inertial_frame_name
        self.name = name
        self.start_time_string = start_time_string
        self.et_start = spice.str2et(start_time_string)
        #self.create_model()

    def function(cls, dt):
        # need cls ref to access things like inertial_frame_name, etc
        et = cls.et_start + dt
        name = cls.name
        SS = spice.sxform(cls.inertial_frame_name, cls.name, et)
        RR, omega_other = spice.xf2rav(SS)
        ang_vel = RR @ omega_other
        #quaternion = spice.m2q(RR.T.copy())
        #quaternion = spice.m2q(RR.copy())
        quaternion = spice.m2q(RR)
        quaternion[1:] *= -1
        return quaternion, ang_vel


    # allow jac_vec_prod, hessian, etc
    # okay, I guess a finite_difference_mixin would be easy to add -- 
    def jacobian(cls, t):
        q, ang_vel = cls.function(t)
        qjac = left_quaternion_product_matrix(q) @ ang_vel/2
        return qjac, np.zeros(3)



print(
    SpiceReferenceFrame(
        "J2000", "moon_pa", "2026-1-28 6:42:03.51 UTC"
    )(0).output()
)







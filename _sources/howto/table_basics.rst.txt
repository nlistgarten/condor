
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "howto/table_basics.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_howto_table_basics.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_howto_table_basics.py:


============
Tabular Data
============

.. GENERATED FROM PYTHON SOURCE LINES 8-29

It is often useful to interpolate pre-existing data. For this, the
:class:`~condor.contrib.TableLookup` model provides a convenient way to specify the
interpolant input and output data. This model also provids an example of using a
:class:`~condor.contrib.ExternalSolverWrapper` by wrapping  uses the `ndsplines
<https://ndsplines.readthedocs.io/>`_ library to perform the interpolation and
compute derivatives as needed for tensor-product B-splines.  Note that this table
model assumes fixed input and output data, but a model with variable input and output
data could be defined as needs arise.

Because :class:`TableLookup` is an :class:`ExternalSolverWrapper`, the declaration of
a model quite different from a standard :class:`ModelTemplate`,
with the relevant data is passed in in a way that appears more similar to a standard
Python object instantiation with arguments for the input data, output data, degree,
and boundary conditions. Condor supports any number of inputs, and automatically
computes the derivatives :math:`\frac{dy_i}{dx_j}` as needed.

Basic Usage
-----------

Here we demonstrate the construction of a single-input, single-output table for the
:math:`sin` function

.. GENERATED FROM PYTHON SOURCE LINES 29-46

.. code-block:: Python


    import numpy as np

    import condor
    from condor.backend import operators as ops

    # input and output data are dictionaries with keys for the name of the element and
    # values to construct the interpolant.
    data_x = dict(x=np.linspace(-1, 1, 5) * ops.pi)
    data_y = dict(y=ops.sin(data_x["x"]))
    SinTable = condor.TableLookup(data_x, data_y)


    out = SinTable(np.pi / 2)
    print(out.y)
    assert np.isclose(out.y, 1)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    [1.]




.. GENERATED FROM PYTHON SOURCE LINES 47-52

Multiple Inputs
---------------

Next, we construct a table with two inputs and a single output. The output data should
have shape ``(n_x1, n_x2, ...)``

.. GENERATED FROM PYTHON SOURCE LINES 52-72

.. code-block:: Python


    Table = condor.TableLookup(
        dict(
            x1=[-1, -0.5, 0, 0.5, 1],
            x2=[0, 1, 2, 3],
        ),
        dict(
            y1=[
                [0, 1, 2, 3],
                [3, 4, 5, 6],
                [6, 7, 8, 9],
                [8, 7, 6, 5],
                [4, 3, 2, 1],
            ]
        ),
    )

    tab_out = Table(x1=0.5, x2=0.1)
    print(tab_out.output)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    TableLookupOutput(y1=array([7.62482755]))




.. GENERATED FROM PYTHON SOURCE LINES 73-79

Spline Degree and Boundary Conditions
-------------------------------------

Next we demonstrate specifying the degrees (and boundary conditions) for the
:code:`SinTable`. Note that these can be specified for each input (and boundary)
independently, or a single custom value can be broadcast to each input (and boundary).

.. GENERATED FROM PYTHON SOURCE LINES 79-103

.. code-block:: Python


    from matplotlib import pyplot as plt

    eval_x = np.linspace(-1.1, 1.1, 100) * np.pi

    fig, ax = plt.subplots(constrained_layout=True)
    for k in [0, 1, 3]:
        # for cubic polynomial, use constant slope (constant first derivative, 0 second
        # derivative) boundary condition instead of default not-a-knot (constant, non-zero,
        # second derivative)
        bcs = (2, 0) if k == 3 else (-1, 0)

        SinTable = condor.TableLookup(data_x, data_y, degrees=k, bcs=bcs)
        y = np.array([SinTable(x).y for x in eval_x]).squeeze()

        plt.plot(eval_x, y, label=f"k={k}")

    plt.plot(data_x["x"], data_y["y"], "ko")
    plt.plot(eval_x, np.sin(eval_x), "k--", label="true")

    plt.grid(True)
    plt.legend()

    plt.show()



.. image-sg:: /howto/images/sphx_glr_table_basics_001.png
   :alt: table basics
   :srcset: /howto/images/sphx_glr_table_basics_001.png
   :class: sphx-glr-single-img






.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 0.424 seconds)


.. _sphx_glr_download_howto_table_basics.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: table_basics.ipynb <table_basics.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: table_basics.py <table_basics.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: table_basics.zip <table_basics.zip>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
